#version 460 core
#define MAX_DIST 100
#define M_PI 3.1415926535897932384626433832795
#define EPS 1e-5
#define SAMPLES 1

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct VoxelData {
    float q[10];
    float bmin[3];
    float bmax[3];
    float sigma_a[3];
    float sigma_s[3];
    float sigma;
};

layout (rgba32f, binding = 0) uniform image2D imgOutput;

layout (std430, binding = 1) readonly buffer ssbo {
    VoxelData voxels[];
};

uniform mat4 viewInv;
uniform mat4 projectionInv;
uniform vec3 cameraPos;
uniform vec2 resolution;
uniform int voxelSize;

struct Ray {
    vec3 o;
    vec3 d;
};

struct IntersectResult {
    vec3 intersection;
    float t;
    int idx;
};

struct PhaseFunction {
    float g;
};

// Random number generation using pcg32i_random_t, using inc = 1. Our random state is a uint.
uint stepRNG(uint rngState) {
  return rngState * 747796405 + 1;
}

// Steps the RNG and returns a floating-point value between 0 and 1 inclusive.
float stepAndOutputRNGFloat(inout uint rngState) {
  // Condensed version of pcg_output_rxs_m_xs_32_32, with simple conversion to floating-point [0,1].
  rngState  = stepRNG(rngState);
  uint word = ((rngState >> ((rngState >> 28) + 4)) ^ rngState) * 277803737;
  word      = (word >> 22) ^ word;
  return float(word) / 4294967295.0f;
}

uint rngState =  (600 * gl_GlobalInvocationID.x + gl_GlobalInvocationID.y);

float random() {
    return stepAndOutputRNGFloat(rngState);
}

float sampleExponential(float u, float a) {
    return -log(1-u)/a;
}

int sampleEvent(float u, float pAbsorb, float pScatter, float pNull) {
    if (u < pAbsorb) return 0;
    if (u < pAbsorb+pScatter) return 1;
    return 2;
}

float average(vec3 v) {
    return (v.x+v.y+v.z)/3.f;
}

float f(float q[10], vec3 p) {
    return q[0]*p.x*p.x+q[1]*p.y*p.y+q[2]*p.z*p.z+q[3]*p.x*p.y+q[4]*p.x*p.z+q[5]*p.y*p.z+q[6]*p.x+q[7]*p.y+q[8]*p.z+q[9];
}

vec3 df(float q[10], vec3 p) {
    return vec3(
        2*p.x*q[0]+p.y*q[3]+p.z*q[4]+q[6],
        2*p.y*q[1]+p.x*q[3]+p.z*q[5]+q[7],
        2*p.z*q[2]+p.x*q[4]+p.y*q[5]+q[8]
        );
}

PhaseFunction getPhaseFunction(VoxelData voxel, vec3 intr) {
    PhaseFunction phase = {.5f};
    return phase;
}

float phasePdf(PhaseFunction phase, vec3 wo, vec3 wi) {
    float denom = 1+phase.g*phase.g+2*phase.g*dot(wo, wi);
    return 1.f/M_PI*(1.f-phase.g*phase.g)/(denom*sqrt(denom));
}

float getMinimumQuadraticSolution(Ray r, float a, float b, float c, float tMin, float tMax, vec3 bmin, vec3 bmax) {
    float delta = b*b-4*a*c, t = MAX_DIST;
    if (delta >= 0) {
        float sqrtDelta = sqrt(delta);
        float temp = (-b-sqrtDelta)/(2*a);
        if (tMin < temp && temp < tMax) {
            vec3 p = r.o+temp*r.d;
            if (min(p, bmin) == bmin && max(p, bmax) == bmax) {
                t = min(t, temp);
            }
        }
        temp = (-b+sqrtDelta)/(2*a);
        if (tMin < temp && temp < tMax) {
            vec3 p = r.o+temp*r.d;
            if (min(p, bmin) == bmin && max(p, bmax) == bmax) {
                t = min(t, temp);
            }
        }
    }
    return t;
}

float intersectAABB(Ray r, vec3 bmin, vec3 bmax, float tMin, float tMax) {
    vec3 tmin = (bmin-r.o)/r.d;
    vec3 tmax = (bmax-r.o)/r.d;
    vec3 t1 = min(tmin, tmax);
    vec3 t2 = max(tmin, tmax);
    float tEnter = max(max(t1.x, t1.y), t1.z);
    float tExit = min(min(t2.x, t2.y), t2.z);
    if (tEnter < tExit && tExit >= 0) {
        if (tMin < tEnter && tEnter < tMax) return tEnter;
        if (tMin < tExit && tExit < tMax) return tExit;
    }
    return MAX_DIST;
}

IntersectResult intersectVoxel(Ray r, int idx, float tMin, float tMax) {
    VoxelData voxel = voxels[idx];
    vec3 bmin = {voxel.bmin[0], voxel.bmin[1], voxel.bmin[2]};
    vec3 bmax = {voxel.bmax[0], voxel.bmax[1], voxel.bmax[2]};
    float a = voxel.q[0]*r.d.x*r.d.x+voxel.q[1]*r.d.y*r.d.y+voxel.q[2]*r.d.z*r.d.z
        +voxel.q[3]*r.d.x*r.d.y+voxel.q[4]*r.d.x*r.d.z+voxel.q[5]*r.d.y*r.d.z;
    float b = 2*voxel.q[0]*r.o.x*r.d.x+2*voxel.q[1]*r.o.y*r.d.y+2*voxel.q[2]*r.o.z*r.d.z
        +voxel.q[3]*(r.o.x*r.d.y+r.o.y*r.d.x)+voxel.q[4]*(r.o.x*r.d.z+r.o.z*r.d.x)+voxel.q[5]*(r.o.y*r.d.z+r.o.z*r.d.y)
        +voxel.q[6]*r.d.x+voxel.q[7]*r.d.y+voxel.q[8]*r.d.z;
    float c = f(voxel.q, r.o);
    //float c = f(voxel.q, r.o);
    // float a = voxel.hullQ[0]*r.d.x*r.d.x+voxel.hullQ[1]*r.d.y*r.d.y+voxel.hullQ[2]*r.d.z*r.d.z
    //     +voxel.hullQ[3]*r.d.x*r.d.y+voxel.hullQ[4]*r.d.x*r.d.z+voxel.hullQ[5]*r.d.y*r.d.z;
    // float b = 2*voxel.hullQ[0]*r.o.x*r.d.x+2*voxel.hullQ[1]*r.o.y*r.d.y+2*voxel.hullQ[2]*r.o.z*r.d.z
    //     +voxel.hullQ[3]*(r.o.x*r.d.y+r.o.y*r.d.x)+voxel.hullQ[4]*(r.o.x*r.d.z+r.o.z*r.d.x)+voxel.hullQ[5]*(r.o.y*r.d.z+r.o.z*r.d.y)
    //     +voxel.hullQ[6]*r.d.x+voxel.hullQ[7]*r.d.y+voxel.hullQ[8]*r.d.z;
    // float c = f(voxel.hullQ, r.o);
    float sigma = voxel.sigma;
    IntersectResult res;
    float upSol = getMinimumQuadraticSolution(r, a, b, c-3.f*sigma, tMin, tMax, bmin, bmax);
    float downSol = getMinimumQuadraticSolution(r, a, b, c+3.f*sigma, tMin, tMax, bmin, bmax);
    res.t = min(upSol, downSol);
    if (res.t < MAX_DIST) {
        float aabb = intersectAABB(r, bmin, bmax, tMin, tMax);
        res.t = min(res.t, aabb);
        res.intersection = r.o+res.t*r.d;
        res.idx = idx;
    }
    return res;
}

IntersectResult intersect(Ray r) {
    IntersectResult res;
    res.t = MAX_DIST;
    int idx = -1;
    for (int i = 0; i < voxelSize; i++) {
        IntersectResult intr = intersectVoxel(r, i, EPS, res.t);
        if (intr.t < res.t) {
            res = intr;
        }
    }
    return res;
}

vec3 lightPos = vec3(2.f);
vec3 lightL = vec3(1.f);

vec3 sampleLd(vec3 intr, vec3 wo, vec3 beta, vec3 r_p, PhaseFunction phase) {
    vec3 wi = lightPos-intr;
    float lightDist  = length(wi);
    wi = normalize(wi);
    vec3 L = lightL/(lightDist*lightDist);
    float p_l = 1.f;
    float scatterPdf = phasePdf(phase, wo, wi);
    vec3 f_hat = vec3(scatterPdf);

    vec3 T_ray = vec3(1.f);
    vec3 r_l = vec3(1.f);
    vec3 r_u = vec3(1.f);
    Ray lightRay = {intr, wi};
    while (lightRay.d != vec3(0.f)) {
        IntersectResult intrRes = intersect(lightRay);
        VoxelData voxel = voxels[intrRes.idx];
        float func = f(voxel.q, lightRay.o);
        if (-3.f*voxel.sigma <= func && func <= 3.f*voxel.sigma) {
            // In medium
            float tMax = intrRes.t;
            if (intrRes.t >= MAX_DIST)
                tMax = lightDist;
            vec3 sigma_A = vec3(voxel.sigma_a[0], voxel.sigma_a[1], voxel.sigma_a[2]);
            vec3 sigma_S = vec3(voxel.sigma_s[0], voxel.sigma_s[1], voxel.sigma_s[2]);
            vec3 sigma_maj = sigma_A+sigma_S;
            vec3 T_maj = vec3(1.f);
            if (sigma_maj[0] == 0) {
                T_maj *= exp(-tMax*sigma_maj);
            } else {
                float tMin = 0;
                while (true) {
                    float t = tMin+sampleExponential(random(), sigma_maj[0]);
                    if (t < tMax) {
                        T_maj *= exp(-(t-tMin)*sigma_maj);

                        vec3 sigma_a = sigma_A;
                        vec3 sigma_s = sigma_S;
                        vec3 sigma_n = sigma_maj-sigma_a-sigma_s;
                        float pdf = T_maj[0]*sigma_maj[0];
                        T_ray *= T_maj*sigma_n/pdf;
                        r_l *= T_maj*sigma_maj/pdf;
                        r_u *= T_maj*sigma_n/pdf;

                        vec3 Tr = T_ray/average(r_l+r_u);
                        if (max(Tr[0], max(Tr[1], Tr[2])) < 0.05f) {
                            float q = 0.75f;
                            if (random() < q)
                                T_ray = vec3(0.f);
                            else
                                T_ray /= 1-q;
                        }
                        if (T_ray == vec3(0.f)) {
                            break;
                        }

                        T_maj = vec3(1.f);
                        tMin = t;
                    } else {
                        float dt = tMax-tMin;
                        T_maj *= exp(-dt*sigma_maj);
                        break;
                    }
                }
            }
            T_ray *= T_maj/T_maj[0];
            r_l *= T_maj/T_maj[0];
            r_u *= T_maj/T_maj[0];
        }
        if (intr.t >= MAX_DIST)
            break;
        lightRay.o = intrRes.intersection;
        lightRay.d = wi;
    }
    r_l *= r_p*p_l;
    r_u *= r_p*scatterPdf;
    return beta*f_hat*T_ray*L/average(r_l);
}

vec3 LiVoxel(Ray r, int idx) {
    bool scattered = false, terminated = false;
    vec3 beta = vec3(1.f);
    vec3 r_u = vec3(1.f);
    vec3 r_l = vec3(1.f);
    float tMax = intersectVoxel(r, idx, EPS, MAX_DIST).t;
    if (tMax >= MAX_DIST)
        return vec3(0.f);
    vec3 T_maj = vec3(1.f);
    VoxelData voxel = voxels[idx];
    vec3 sigma_A = vec3(voxel.sigma_a[0], voxel.sigma_a[1], voxel.sigma_a[2]);
    vec3 sigma_S = vec3(voxel.sigma_s[0], voxel.sigma_s[1], voxel.sigma_s[2]);
    vec3 sigma_maj = sigma_A+sigma_S;
    if (sigma_maj[0] == 0) {
        T_maj *= exp(-tMax*sigma_maj);
        return vec3(1.f);
    }
    float tMin = 0;
    while (true) {
        float t = tMin+sampleExponential(random(), sigma_maj[0]);
        if (t < tMax) {
            T_maj *= exp(-(t-tMin)*sigma_maj);
            if (beta == vec3(0.f)) {
                return vec3(1.f);
            }
            // TODO: SGGX
            vec3 sigma_a = sigma_A;
            vec3 sigma_s = sigma_S;
            
            float pAbsorb = sigma_a[0]/sigma_maj[0];
            float pScatter = sigma_s[0]/sigma_maj[0];
            float pNull = max(0.f, 1-pAbsorb-pScatter);
            int mode = sampleEvent(random(), pAbsorb, pScatter, pNull);
            if (mode == 0) {
                return vec3(0.f);
            } else if (mode == 1) {
                float pdf = T_maj[0]*sigma_s[0];
                beta *= T_maj*sigma_s/pdf;
                r_u *= T_maj*sigma_s/pdf;
                vec3 p = r.o+t*r.d;
                PhaseFunction phase = getPhaseFunction(voxel, p);
                return vec3(1.f);
                //return sampleLd(p, -r.d, beta, r_u, phase);
            } else {
                vec3 sigma_n = max(sigma_maj-sigma_a-sigma_s, vec3(0.f));
                float pdf = T_maj[0]*sigma_n[0];
                beta *= T_maj*sigma_n/pdf;
                if (pdf == 0)
                    beta = vec3(0.f);
                r_u *= T_maj*sigma_n/pdf;
                r_l *= T_maj*sigma_maj/pdf;
                if (beta == vec3(0.f) || r_u == vec3(0.f)) {
                    return vec3(1.f);
                }
            }

            T_maj = vec3(1.f);
            tMin = t;
        } else {
            float dt = tMax-tMin;
            T_maj *= exp(-dt*sigma_maj);
            break;
        }
    }
    return vec3(0.f);
}

vec3 Li(Ray r) {
    vec3 L = vec3(0.f);
    IntersectResult intr = intersect(r);
    if (intr.t < MAX_DIST) {
        Ray voxelRay = {intr.intersection, r.d};
        L += LiVoxel(voxelRay, intr.idx);
    } else {
        L += vec3(.5f, .7f, 1);
    }
    return L;
}

// vec3 shadeVoxel(IntersectResult intr) {
//     VoxelData voxel = voxels[intr.idx];
//     vec3 N = normalize(df(voxel.q, intr.intersection));
//     vec3 V = cameraPos-intr.intersection;
//     if (dot(N, V) < 0) {
//         N = -N;
//     }
//     //return N/2.f+.5f;
//     vec3 lightPos = vec3(1.f, 1.f, 1.f);
//     vec3 L = lightPos-intr.intersection;
//     float r = length(L);
//     L = normalize(L);
//     vec3 H = normalize(L+V);
//     float NdotL = dot(N, L);
//     float NdotH = dot(N, H);
//     vec3 Ld = vec3(1.f)*vec3(1.f)/(r*r)*max(NdotL, 0.f);
//     vec3 Ls = vec3(1.f)*vec3(1.f)/(r*r)*pow(max(NdotH, 0.f), 16.f);
//     return Ld+Ls;
// }

void main() {
    vec2 imgSize = vec2(imageSize(imgOutput));
    vec2 uv = (gl_GlobalInvocationID.xy)/imgSize*2.f-1.f;
    vec4 ndcRayDir = vec4(uv, 1.f, 1.f);
    vec4 worldRayDir = viewInv*projectionInv*ndcRayDir;
    Ray r = {cameraPos, worldRayDir.xyz/worldRayDir.w};
    r.d = normalize(r.d);
    // IntersectResult intr = intersect(r);
    // if (intr.t < MAX_DIST) {
    //     hit = true;
    //     color += shadeVoxel(intr)/SAMPLES;
    // }
    // if (!hit)
    //     color = vec3(.5f, .7f, 1);
    vec3 color = imageLoad(imgOutput, ivec2(gl_GlobalInvocationID.xy)).rgb;
    color += Li(r)/SAMPLES;
    imageStore(imgOutput, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.f));
}