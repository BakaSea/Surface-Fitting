#version 460 core
#define MAX_DIST 100
#define M_PI 3.14159265358979323846
#define INV4PI 0.07957747154594766788
#define EPS 1e-5

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct VoxelData {
    float q[10];
    float bmin[3];
    float bmax[3];
    float sigma_a[3];
    float sigma_s[3];
    float sigma;
};

layout (rgba32f, binding = 0) uniform image2D imgOutput;

layout (std430, binding = 1) readonly buffer ssbo {
    VoxelData voxels[];
};

uniform mat4 viewInv;
uniform mat4 projectionInv;
uniform vec3 cameraPos;
uniform vec2 resolution;
uniform int voxelSize;
uniform int currentSample;

struct Ray {
    vec3 o;
    vec3 d;
};

struct IntersectResult {
    vec3 intersection;
    float t;
    int idx;
};

struct PhaseFunction {
    float g;
};

// Random number generation using pcg32i_random_t, using inc = 1. Our random state is a uint.
uint stepRNG(uint rngState) {
  return rngState * 747796405 + 1;
}

// Steps the RNG and returns a floating-point value between 0 and 1 inclusive.
float stepAndOutputRNGFloat(inout uint rngState) {
  // Condensed version of pcg_output_rxs_m_xs_32_32, with simple conversion to floating-point [0,1].
  rngState  = stepRNG(rngState);
  uint word = ((rngState >> ((rngState >> 28) + 4)) ^ rngState) * 277803737;
  word      = (word >> 22) ^ word;
  return float(word) / 4294967295.0f;
}

uint rngState =  (600 * gl_GlobalInvocationID.x + gl_GlobalInvocationID.y)*currentSample;

float random() {
    return stepAndOutputRNGFloat(rngState);
}

float sampleExponential(float u, float a) {
    return -log(1.f-u)/a;
}

int sampleEvent(float u, float pAbsorb, float pScatter, float pNull) {
    if (u < pAbsorb) return 0;
    if (u < pAbsorb+pScatter) return 1;
    return 2;
}

float average(vec3 v) {
    return (v.x+v.y+v.z)/3.f;
}

float f(float q[10], vec3 p) {
    return q[0]*p.x*p.x+q[1]*p.y*p.y+q[2]*p.z*p.z+q[3]*p.x*p.y+q[4]*p.x*p.z+q[5]*p.y*p.z+q[6]*p.x+q[7]*p.y+q[8]*p.z+q[9];
}

vec3 df(float q[10], vec3 p) {
    return vec3(
        2*p.x*q[0]+p.y*q[3]+p.z*q[4]+q[6],
        2*p.y*q[1]+p.x*q[3]+p.z*q[5]+q[7],
        2*p.z*q[2]+p.x*q[4]+p.y*q[5]+q[8]
        );
}

PhaseFunction getPhaseFunction(VoxelData voxel, vec3 intr) {
    PhaseFunction phase = {.6f};
    return phase;
}

float phasePdf(PhaseFunction phase, vec3 wo, vec3 wi) {
    float denom = 1+phase.g*phase.g+2*phase.g*dot(wo, wi);
    return INV4PI*(1.f-phase.g*phase.g)/(denom*sqrt(denom));
}

float getSigmaAttenuation(float q[10], vec3 p) {
    float d = f(q, p)/length(df(q, p));
    return d;
}

float getMinimumQuadraticSolution(Ray r, float a, float b, float c, float tMin, float tMax, vec3 bmin, vec3 bmax) {
    float delta = b*b-4*a*c, t = MAX_DIST;
    if (delta >= 0) {
        float sqrtDelta = sqrt(delta);
        float temp = (-b-sqrtDelta)/(2*a);
        if (tMin < temp && temp < tMax) {
            vec3 p = r.o+temp*r.d;
            if (min(p, bmin) == bmin && max(p, bmax) == bmax) {
                t = min(t, temp);
            }
        }
        temp = (-b+sqrtDelta)/(2*a);
        if (tMin < temp && temp < tMax) {
            vec3 p = r.o+temp*r.d;
            if (min(p, bmin) == bmin && max(p, bmax) == bmax) {
                t = min(t, temp);
            }
        }
    }
    return t;
}

float intersectAABB(Ray r, vec3 bmin, vec3 bmax, float tMin, float tMax) {
    vec3 tmin = (bmin-r.o)/r.d;
    vec3 tmax = (bmax-r.o)/r.d;
    vec3 t1 = min(tmin, tmax);
    vec3 t2 = max(tmin, tmax);
    float tEnter = max(max(t1.x, t1.y), t1.z);
    float tExit = min(min(t2.x, t2.y), t2.z);
    if (tEnter < tExit && tExit >= 0) {
        if (tMin < tEnter && tEnter < tMax) return tEnter;
        if (tMin < tExit && tExit < tMax) return tExit;
    }
    return MAX_DIST;
}

IntersectResult intersectVoxel(Ray r, int idx, float tMin, float tMax) {
    VoxelData voxel = voxels[idx];
    vec3 bmin = {voxel.bmin[0], voxel.bmin[1], voxel.bmin[2]};
    vec3 bmax = {voxel.bmax[0], voxel.bmax[1], voxel.bmax[2]};
    float a = voxel.q[0]*r.d.x*r.d.x+voxel.q[1]*r.d.y*r.d.y+voxel.q[2]*r.d.z*r.d.z
        +voxel.q[3]*r.d.x*r.d.y+voxel.q[4]*r.d.x*r.d.z+voxel.q[5]*r.d.y*r.d.z;
    float b = 2*voxel.q[0]*r.o.x*r.d.x+2*voxel.q[1]*r.o.y*r.d.y+2*voxel.q[2]*r.o.z*r.d.z
        +voxel.q[3]*(r.o.x*r.d.y+r.o.y*r.d.x)+voxel.q[4]*(r.o.x*r.d.z+r.o.z*r.d.x)+voxel.q[5]*(r.o.y*r.d.z+r.o.z*r.d.y)
        +voxel.q[6]*r.d.x+voxel.q[7]*r.d.y+voxel.q[8]*r.d.z;
    float c = f(voxel.q, r.o);
    //float c = f(voxel.q, r.o);
    // float a = voxel.hullQ[0]*r.d.x*r.d.x+voxel.hullQ[1]*r.d.y*r.d.y+voxel.hullQ[2]*r.d.z*r.d.z
    //     +voxel.hullQ[3]*r.d.x*r.d.y+voxel.hullQ[4]*r.d.x*r.d.z+voxel.hullQ[5]*r.d.y*r.d.z;
    // float b = 2*voxel.hullQ[0]*r.o.x*r.d.x+2*voxel.hullQ[1]*r.o.y*r.d.y+2*voxel.hullQ[2]*r.o.z*r.d.z
    //     +voxel.hullQ[3]*(r.o.x*r.d.y+r.o.y*r.d.x)+voxel.hullQ[4]*(r.o.x*r.d.z+r.o.z*r.d.x)+voxel.hullQ[5]*(r.o.y*r.d.z+r.o.z*r.d.y)
    //     +voxel.hullQ[6]*r.d.x+voxel.hullQ[7]*r.d.y+voxel.hullQ[8]*r.d.z;
    // float c = f(voxel.hullQ, r.o);
    //float sigma = voxel.sigma;
    float sigma = voxel.sigma;
    IntersectResult res;
    float upSol = getMinimumQuadraticSolution(r, a, b, c-3.f*sigma, tMin, tMax, bmin, bmax);
    float downSol = getMinimumQuadraticSolution(r, a, b, c+3.f*sigma, tMin, tMax, bmin, bmax);
    float aabb = intersectAABB(r, bmin, bmax, tMin, tMax);
    if (aabb < MAX_DIST) {
        float func = f(voxel.q, r.o+aabb*r.d);
        if (func < -3.f*sigma || 3.f*sigma < func) {
            aabb = MAX_DIST;
        }
    }
    res.t = min(min(upSol, downSol), aabb);
    if (res.t < MAX_DIST) {
        res.intersection = r.o+res.t*r.d;
        res.idx = idx;
    }
    return res;
}

IntersectResult intersect(Ray r, float tMax) {
    IntersectResult res;
    res.t = MAX_DIST;
    res.idx = -1;
    for (int i = 0; i < voxelSize; i++) {
        IntersectResult intr = intersectVoxel(r, i, EPS, tMax);
        if (intr.t < res.t) {
            res = intr;
        }
    }
    return res;
}

vec3 lightPos = vec3(0.f, 1.f, 0.f);
vec3 lightI = vec3(100.f);
//vec3 ambientL = vec3(.5f, .7f, 1.f);
vec3 ambientL = vec3(0.f);

vec3 sampleLd(vec3 intr, vec3 wo, vec3 beta, vec3 r_p, PhaseFunction phase) {
    vec3 wi = lightPos-intr;
    float sqrDist  = dot(wi, wi);
    wi = normalize(wi);
    vec3 L = lightI/sqrDist;
    float p_l = 1.f;
    float scatterPdf = phasePdf(phase, wo, wi);
    vec3 f_hat = vec3(scatterPdf);

    vec3 T_ray = vec3(1.f);
    vec3 r_l = vec3(1.f);
    vec3 r_u = vec3(1.f);
    Ray lightRay = {intr, wi};
    IntersectResult intrRes;
    intrRes.t = MAX_DIST;
    while (intrRes.t > EPS) {
        float dist = length(lightPos-lightRay.o);
        intrRes = intersect(lightRay, dist);
        if (intrRes.idx >= 0) {
            VoxelData voxel = voxels[intrRes.idx];
            float func = f(voxel.q, lightRay.o+lightRay.d*intrRes.t*0.5f);
            if (-3.f*voxel.sigma <= func && func <= 3.f*voxel.sigma) {
                // In medium
                float tMax = intrRes.t;
                if (intrRes.t >= MAX_DIST)
                    tMax = dist;
                vec3 sigma_A = vec3(voxel.sigma_a[0], voxel.sigma_a[1], voxel.sigma_a[2]);
                vec3 sigma_S = vec3(voxel.sigma_s[0], voxel.sigma_s[1], voxel.sigma_s[2]);
                vec3 sigma_maj = sigma_A+sigma_S;
                vec3 T_maj = vec3(1.f);
                if (sigma_maj[0] == 0) {
                    T_maj *= exp(-tMax*sigma_maj);
                } else {
                    float tMin = 0;
                    while (true) {
                        float t = tMin+sampleExponential(random(), sigma_maj[0]);
                        if (t < tMax) {
                            T_maj *= exp(-(t-tMin)*sigma_maj);

                            vec3 p = lightRay.o+lightRay.d*t;
                            vec3 sigma_a = sigma_A*getSigmaAttenuation(voxel.q, p);
                            vec3 sigma_s = sigma_S*getSigmaAttenuation(voxel.q, p);

                            vec3 sigma_n = sigma_maj-sigma_a-sigma_s;
                            float pdf = T_maj[0]*sigma_maj[0];
                            T_ray *= T_maj*sigma_n/pdf;
                            r_l *= T_maj*sigma_maj/pdf;
                            r_u *= T_maj*sigma_n/pdf;

                            vec3 Tr = T_ray/average(r_l+r_u);
                            if (max(Tr[0], max(Tr[1], Tr[2])) < 0.05f) {
                                float q = 0.75f;
                                if (random() < q)
                                    T_ray = vec3(0.f);
                                else
                                    T_ray /= 1-q;
                            }
                            if (T_ray == vec3(0.f)) {
                                return vec3(0.f);
                            }

                            T_maj = vec3(1.f);
                            tMin = t;
                        } else {
                            float dt = tMax-tMin;
                            T_maj *= exp(-dt*sigma_maj);
                            break;
                        }
                    }
                }
                T_ray *= T_maj/T_maj[0];
                r_l *= T_maj/T_maj[0];
                r_u *= T_maj/T_maj[0];
            }
        }
        if (intrRes.t >= MAX_DIST)
            break;
        lightRay.o = intrRes.intersection;
        lightRay.d = wi;
    }
    r_l *= r_p*p_l;
    r_u *= r_p*scatterPdf;
    return beta*f_hat*T_ray*L/average(r_l);
}

vec3 LiVoxel(Ray r, int idx) {
    bool scattered = false, terminated = false;
    vec3 beta = vec3(1.f);
    vec3 r_u = vec3(1.f);
    vec3 r_l = vec3(1.f);
    float tMax = intersectVoxel(r, idx, EPS, MAX_DIST).t;
    if (tMax >= MAX_DIST)
        tMax = 0.f;
    //return vec3(tMax);
    vec3 T_maj = vec3(1.f);
    VoxelData voxel = voxels[idx];
    vec3 sigma_A = vec3(voxel.sigma_a[0], voxel.sigma_a[1], voxel.sigma_a[2]);
    vec3 sigma_S = vec3(voxel.sigma_s[0], voxel.sigma_s[1], voxel.sigma_s[2]);
    vec3 sigma_maj = sigma_A+sigma_S;
    if (sigma_maj[0] == 0) {
        T_maj *= exp(-tMax*sigma_maj);
    } else {
        float tMin = 0;
        while (true) {
            float t = tMin+sampleExponential(random(), sigma_maj[0]);
            if (t < tMax) {
                T_maj *= exp(-(t-tMin)*sigma_maj);
                if (beta == vec3(0.f)) {
                    return vec3(0.f);
                }
                // TODO: SGGX
                vec3 p = r.o+r.d*t;
                vec3 sigma_a = sigma_A*getSigmaAttenuation(voxel.q, p);
                vec3 sigma_s = sigma_S*getSigmaAttenuation(voxel.q, p);
                
                float pAbsorb = sigma_a[0]/sigma_maj[0];
                float pScatter = sigma_s[0]/sigma_maj[0];
                float pNull = max(0.f, 1.f-pAbsorb-pScatter);
                int mode = sampleEvent(random(), pAbsorb, pScatter, pNull);
                if (mode == 0) {
                    return vec3(0.f);
                    //return vec3(0.f, 1.f, 0.f);
                } else if (mode == 1) {
                    float pdf = T_maj[0]*sigma_s[0];
                    beta *= T_maj*sigma_s/pdf;
                    r_u *= T_maj*sigma_s/pdf;
                    vec3 p = r.o+t*r.d;
                    PhaseFunction phase = getPhaseFunction(voxel, p);
                    //return vec3(1.f);
                    return sampleLd(p, -r.d, beta, r_u, phase);
                } else {
                    vec3 sigma_n = max(sigma_maj-sigma_a-sigma_s, vec3(0.f));
                    float pdf = T_maj[0]*sigma_n[0];
                    beta *= T_maj*sigma_n/pdf;
                    if (pdf == 0)
                        beta = vec3(0.f);
                    r_u *= T_maj*sigma_n/pdf;
                    r_l *= T_maj*sigma_maj/pdf;
                    if (beta == vec3(0.f) || r_u == vec3(0.f)) {
                        break;
                    }
                }

                T_maj = vec3(1.f);
                tMin = t;
            } else {
                float dt = tMax-tMin;
                T_maj *= exp(-dt*sigma_maj);
                //return vec3(1.f, 0.f, 0.f);
                break;
            }
        }
    }
    beta *= T_maj/T_maj[0];
    r_u *= T_maj/T_maj[0];
    r_l *= T_maj/T_maj[0];
    
    return beta*ambientL/average(r_u);
}

vec3 shadeVoxel(IntersectResult intr) {
    VoxelData voxel = voxels[intr.idx];
    vec3 N = normalize(df(voxel.q, intr.intersection));
    vec3 V = cameraPos-intr.intersection;
    if (dot(N, V) < 0) {
        N = -N;
    }
    return N/2.f+.5f;
}


vec3 Li(Ray r) {
    vec3 L = vec3(0.f);
    IntersectResult intr = intersect(r, MAX_DIST);
    if (intr.t < MAX_DIST) {
        Ray voxelRay = {intr.intersection, r.d};
        //L += shadeVoxel(intr);
        L += LiVoxel(voxelRay, intr.idx);
    } else {
        L += ambientL;
    }
    return L;
}

void main() {
    vec2 imgSize = vec2(imageSize(imgOutput));
    vec2 uv = (gl_GlobalInvocationID.xy+vec2(random(), random()))/imgSize*2.f-1.f;
    vec4 ndcRayDir = vec4(uv, 1.f, 1.f);
    vec4 worldRayDir = viewInv*projectionInv*ndcRayDir;
    Ray r = {cameraPos, worldRayDir.xyz/worldRayDir.w};
    r.d = normalize(r.d);
    // IntersectResult intr = intersect(r);
    // if (intr.t < MAX_DIST) {
    //     hit = true;
    //     color += shadeVoxel(intr)/SAMPLES;
    // }
    // if (!hit)
    //     color = vec3(.5f, .7f, 1);
    vec3 color = imageLoad(imgOutput, ivec2(gl_GlobalInvocationID.xy)).rgb;
    color *= (currentSample-1.f)/currentSample;
    //color = Li(r);
    color += Li(r)/currentSample;
    imageStore(imgOutput, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.f));
}